-- OpenAI Batch Results Fetcher (first draft)
--
-- Purpose: Given the identifiers saved by the companion "batch-cache-loader" tool
-- (especially the batch_id), check the status of the batch. If it's completed,
-- download the output JSONL and write one file per request (by custom_id) into a
-- results directory, skipping any that already exist. The tool does *not* poll;
-- it inspects once and exits so external orchestration can re-run it as needed.
--
-- Usage:
--   OPENAI_API_KEY=sk-... stack run fetcher -- out.json results/
-- or
--   cabal run fetcher -- out.json results/
--
-- Arguments:
--   1) path to out.json generated by the first utility (contains batch_id, etc.)
--   2) path to results folder (will be created if missing). Each fetched item is
--      written as <custom_id>.json containing the corresponding JSON line.
--
-- Notes:
--   • This tool expects the batch endpoint to be /v1/responses (as created by
--     the paired loader). If the batch is not "completed", it prints a summary
--     and exits 0 without downloading anything.
--   • On completion, it uses GET /v1/files/{output_file_id}/content to stream
--     the JSONL of results, then writes missing custom_ids.

module Commands.Fetch (doFetch) where

import qualified Data.ByteString.Lazy as LBS
import qualified Data.Set as S
import qualified Data.Text as T
import qualified Data.Text.Encoding as TE
import Data.Foldable (for_)

import qualified Data.Aeson as A
import qualified Data.Aeson.Types as AT
import qualified Data.Aeson.Encode.Pretty as AP
import qualified Data.ByteString.Char8 as BS8

import Data.Time.Clock ( getCurrentTime )
import qualified Data.Time.Format as Dfm

import GHC.Generics ( Generic )
import Network.HTTP.Client ( Request(..)
                                                , Response(..)
                                                , Manager
                                                , httpLbs
                                                , method
                                                , newManager
                                                , parseRequest
                                                , requestHeaders
                                                , responseBody
                                                )
import Network.HTTP.Client.TLS ( tlsManagerSettings )
import Network.HTTP.Types (HeaderName)
import System.Directory ( createDirectoryIfMissing, listDirectory )
import System.Environment ( getArgs, lookupEnv )
import System.Exit ( exitFailure )
import System.FilePath ( (</>), takeBaseName, takeExtension )
import System.IO ( hPutStrLn, stderr )

import qualified Options as Opt


-- -------------------------------
-- Shared PersistInfo (from loader)
-- -------------------------------

data PersistInfo = PersistInfo
  { batch_input_file_id :: T.Text
  , batch_id            :: T.Text
  , endpoint            :: T.Text
  , completion_window   :: T.Text
  , model_used          :: T.Text
  } deriving (Show, Generic)

instance A.FromJSON PersistInfo

-- -------------------------------
-- Batch status payload (subset)
-- -------------------------------

data BatchStatus = BatchStatus
  { stId              :: T.Text
  , stStatus          :: T.Text
  , stOutputFileId    :: Maybe T.Text
  , stErrorFileId     :: Maybe T.Text
  , stRequestCounts   :: Maybe A.Value  -- keep flexible for now
  } deriving (Show)


doFetch :: FilePath -> FilePath -> Opt.RunOptions -> IO ()
doFetch persistPath resultsDir rtOpts = do
  mKey <- lookupEnv "OPENAI_API_KEY"
  key  <- maybe (die "Missing OPENAI_API_KEY in env") pure mKey

  -- Read PersistInfo
  bs <- LBS.readFile persistPath
  persistInfo <- case A.eitherDecode bs :: Either String PersistInfo of
    Left e  -> die ("Failed to decode PersistInfo: " ++ e)
    Right v -> pure v

  -- Ensure results dir exists
  createDirectoryIfMissing True resultsDir

  -- Discover existing results: take baseName of *.json files as completed custom_ids
  existingFiles <- listDirectory resultsDir
  let existingIds = S.fromList
        [ T.pack (takeBaseName f)
        | f <- existingFiles
        , takeExtension f == ".json"
        ]

  manager <- newManager tlsManagerSettings

  -- Inspect batch status
  status <- getBatchStatus manager key (T.unpack persistInfo.batch_id)
  case stStatus status of
    "completed" -> do
      putStrLn "Batch is completed. Fetching output JSONL..."
      case stOutputFileId status of
        Nothing -> die "Batch completed but missing output_file_id."
        Just ofid -> do
          jsonl <- getFileContent manager key (T.unpack ofid)
          let linesBS = filter (not . LBS.null) (LBS.split 0x0A jsonl) -- split on '\n'
          (downloaded, skipped) <- foldrM (processLine resultsDir existingIds) (0,0) linesBS
          let summary = A.object
                [ "batch_id"        AT..= stId status
                , "status"          AT..= stStatus status
                , "downloaded"      AT..= downloaded
                , "skipped_existing"AT..= skipped
                , "request_counts"  AT..= stRequestCounts status
                ]
          moment <- getCurrentTime
          let
            fmtMoment = Dfm.formatTime Dfm.defaultTimeLocale "%y%m%d_%H%M%S" moment
          LBS.writeFile (resultsDir </> "batch_summary_" 
                <> fmtMoment
                <> ".json") (AP.encodePretty summary)
          putStrLn $ "Done. Downloaded " ++ show downloaded ++ ", skipped " ++ show skipped ++ "."
    other -> do
      putStrLn $ "Batch status: " ++ T.unpack other
      for_
        (stRequestCounts status)
        $ putStrLn . T.unpack . TE.decodeUtf8 . LBS.toStrict . AP.encodePretty
      putStrLn "No output downloaded (batch not completed)."


parseBatchStatus :: A.Value -> AT.Parser BatchStatus
parseBatchStatus = A.withObject "Batch" $ \o -> do
  idN <- o AT..:  "id"
  statusN <- o AT..:  "status"
  ouptputFileIdN <- o AT..:? "output_file_id"
  errorFileIdN  <- o AT..:? "error_file_id"
  requestCountsN <- o AT..:? "request_counts"
  pure $ BatchStatus idN statusN ouptputFileIdN errorFileIdN requestCountsN


-- -------------------------------
-- Process a single JSONL line
-- -------------------------------

processLine :: FilePath -> S.Set T.Text -> LBS.ByteString -> (Int,Int) -> IO (Int,Int)
processLine resultsDir existingIds line (dl,sk) =
  case A.eitherDecode' line :: Either String A.Value of
    Left _ -> do
      -- Guard against empty/invalid lines; ignore quietly but you may log.
      pure (dl, sk)
    Right v -> do
      let mCid = AT.parseMaybe (A.withObject "line" (AT..: "custom_id")) v
      case mCid of
        Nothing -> pure (dl, sk) -- no custom_id; ignore
        Just cid ->
          if cid `S.member` existingIds
            then pure (dl, sk + 1)
            else do
              let outPath = resultsDir </> (T.unpack cid ++ ".json")
              -- Write the raw JSON object (single line). Keep a trailing newline for readability.
              LBS.writeFile outPath (line <> "\n")
              pure (dl + 1, sk)

-- -------------------------------
-- HTTP helpers
-- -------------------------------

getBatchStatus :: Manager -> String -> String -> IO BatchStatus
getBatchStatus manager apiKey bid = do
  req0 <- parseRequest ("https://api.openai.com/v1/batches/" ++ bid)
  let req = req0 { method = "GET", requestHeaders = authHeaders apiKey }
  resp <- httpLbs req manager
  case A.eitherDecode (responseBody resp) >>= AT.parseEither parseBatchStatus of
    Left e  -> die ("Failed to parse batch status: " ++ e)
    Right s -> pure s

getFileContent :: Manager -> String -> String -> IO LBS.ByteString
getFileContent manager apiKey fid = do
  req0 <- parseRequest ("https://api.openai.com/v1/files/" ++ fid ++ "/content")
  let req = req0 { method = "GET", requestHeaders = authHeaders apiKey }
  resp <- httpLbs req manager
  pure (responseBody resp)

-- Fold for IO
foldrM :: (a -> b -> IO b) -> b -> [a] -> IO b
foldrM f z xs = go xs z where
  go []     acc = pure acc
  go (y:ys) acc = f y acc >>= go ys

-- Common auth headers
authHeaders :: String -> [(HeaderName, BS8.ByteString)]
authHeaders key =
  [ ("Authorization", BS8.pack ("Bearer " <> key))
  ]

-- Error helper
die :: String -> IO a
die msg = hPutStrLn stderr ("[FATAL] " ++ msg) >> exitFailure
